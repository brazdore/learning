O DDD é uma abordagem de desenvolvimento e modelagem de software cujo objetivo é entregar serviços e produtos de qualidade através da integração e comunicação dos desenvolvedores e dos especialistas de negócio. 
Eric Evans, que cunhou o termo DDD, menciona que não surgirão funcionalidades novas e poderosas como consequência de funcionalidades já existentes caso os programadores não estejam interessados no domínio do negócio.
Os blocos básicos de um sistema DDD são: Entities e Value Objects que são responsáveis pelos conceitos de um domínio. O Repository é responsável por acessar e armazenar os dados. O Factory é responsável por criar novos objetos. O Service manipula os dados e realiza operações complexas com as coleções. O Aggregate define uma coleção de objetos do meu domínio que devem ser concebidos como uma unidade. Os Domain Events representam como as operações do domínio de negócio devem se comportar.
Como os desenvolvedores e os especialistas de negócio devem trabalhar juntos, é necessário que não haja ambiguidade nos termos utilizados, isto é, que ambos tenham clareza dos termos empregados; este é o princípio da linguagem ubíqua.
Em projetos com modelos muito complexos, é possível que a implementação dos domínios se torne difícil e confusa. No DDD, surge o Bounded Context, a delimitação conceitual de cada contexto de operações. Uma classe A pode fazer parte de dois contextos diferentes, podendo ter comportamentos e diferentes de acordo com as necessidades do negócio. 
O Context Map é um mapeamento geral do relacionamento das entidades com os contextos e dos contextos com outros contextos dentro de um mesmo projeto, servindo para organizar o trabalho dos times. 
O Shared Kernel é um tipo de relacionamento entre os contextos. Como vários Bounded Contexts podem ser compartilhados dentro de um mesmo domínio, uma alteração em um contexto pode afetar todo o projeto, exigindo comunicação adequada entre todos os times envolvidos.
Em alguns casos, é possível que os Bounded Contexts se relacionem como consumidor/fornecedor, isto é, downstream/upstream, onde um conceito fornece um serviço e outro consome. Como há uma dependência, é necessário que os times se comuniquem para suprir as necessidades de todos. Também é possível que o fornecedor de um serviço não seja parte da equipe, e sim um serviço externo como o PayPal. Assim, todos os Bounded Contexts de um projeto que utilizarem a interface do PayPal estão aceitando as limitações do serviço do fornecedor e os possíveis impactos que alterações do fornecedor podem causar ao projeto. Por fim, a Anticorruption Layer é uma camada de proteção implementada entre dois contextos que serve para proteger um contexto consumidor das mudanças de um contexto fornecedor, e é comum encontrá-las em sistemas legados.